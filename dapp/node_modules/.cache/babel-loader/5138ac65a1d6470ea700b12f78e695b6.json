{"ast":null,"code":"import axios from \"axios\"; // Actions and types\n\nimport * as t from \"../types\";\nimport { BoxStage } from \"../actions/farm\"; // Rootstate\n\n// Utils\nimport { indexerAPI, waterPeriod } from \"../../utils/global\";\nexport const loadBoxes = () => async (dispatch, getState) => {\n  const {\n    accountPkh\n  } = getState().wallet;\n\n  try {\n    // Retrieve boxes\n    const _res = await axios.get(`${indexerAPI}/boxes?address=${accountPkh}`);\n\n    const boxes = []; // Iterate and assign stages\n\n    for (const box of _res.data) {\n      boxes.push({\n        key: box.key,\n        ...findStage(parseInt(box.timesWatered), box.lastWatered)\n      });\n    }\n\n    dispatch({\n      type: t.FarmActionTypes.LOAD_BOXES,\n      payload: boxes\n    });\n  } catch (err) {\n    console.error(err);\n  }\n};\n\nconst findStage = (timesWatered, lastWatered) => {\n  const notWateredIn = Date.now() - new Date(lastWatered).getTime();\n  if (notWateredIn > 2 * waterPeriod && timesWatered !== 5) return {\n    stage: BoxStage.DEAD,\n    waterBy: 0,\n    needsWater: false\n  };else {\n    return {\n      waterBy: 2 * waterPeriod - notWateredIn,\n      needsWater: notWateredIn > waterPeriod,\n      stage: notWateredIn > waterPeriod ? BoxStage[`STAGE_${timesWatered + 1}`] : BoxStage[`STAGE_${timesWatered}`]\n    };\n  }\n};","map":{"version":3,"sources":["/workspace/box-defi/dapp/src/redux/action-creators/farm.ts"],"names":["axios","t","BoxStage","indexerAPI","waterPeriod","loadBoxes","dispatch","getState","accountPkh","wallet","_res","get","boxes","box","data","push","key","findStage","parseInt","timesWatered","lastWatered","type","FarmActionTypes","LOAD_BOXES","payload","err","console","error","notWateredIn","Date","now","getTime","stage","DEAD","waterBy","needsWater"],"mappings":"AACA,OAAOA,KAAP,MAAkB,OAAlB,C,CAEA;;AACA,OAAO,KAAKC,CAAZ,MAAmB,UAAnB;AAEA,SAASC,QAAT,QAA8B,iBAA9B,C,CAEA;;AAGA;AACA,SAASC,UAAT,EAAqBC,WAArB,QAAwC,oBAAxC;AAEA,OAAO,MAAMC,SAAS,GACpB,MACA,OAAOC,QAAP,EAAuCC,QAAvC,KAAoF;AAClF,QAAM;AAAEC,IAAAA;AAAF,MAAiBD,QAAQ,GAAGE,MAAlC;;AAEA,MAAI;AACF;AACA,UAAMC,IAAI,GAAG,MAAMV,KAAK,CAACW,GAAN,CAAW,GAAER,UAAW,kBAAiBK,UAAW,EAApD,CAAnB;;AACA,UAAMI,KAAY,GAAG,EAArB,CAHE,CAIF;;AACA,SAAK,MAAMC,GAAX,IAAkBH,IAAI,CAACI,IAAvB,EAA6B;AAC3BF,MAAAA,KAAK,CAACG,IAAN,CAAW;AACTC,QAAAA,GAAG,EAAEH,GAAG,CAACG,GADA;AAET,WAAGC,SAAS,CAACC,QAAQ,CAACL,GAAG,CAACM,YAAL,CAAT,EAA6BN,GAAG,CAACO,WAAjC;AAFH,OAAX;AAID;;AAEDd,IAAAA,QAAQ,CAAC;AACPe,MAAAA,IAAI,EAAEpB,CAAC,CAACqB,eAAF,CAAkBC,UADjB;AAEPC,MAAAA,OAAO,EAAEZ;AAFF,KAAD,CAAR;AAID,GAhBD,CAgBE,OAAOa,GAAP,EAAY;AACZC,IAAAA,OAAO,CAACC,KAAR,CAAcF,GAAd;AACD;AACF,CAxBI;;AA0BP,MAAMR,SAAS,GAAG,CAChBE,YADgB,EAEhBC,WAFgB,KAG8C;AAC9D,QAAMQ,YAAY,GAAGC,IAAI,CAACC,GAAL,KAAa,IAAID,IAAJ,CAAST,WAAT,EAAsBW,OAAtB,EAAlC;AACA,MAAIH,YAAY,GAAG,IAAIxB,WAAnB,IAAkCe,YAAY,KAAK,CAAvD,EACE,OAAO;AAAEa,IAAAA,KAAK,EAAE9B,QAAQ,CAAC+B,IAAlB;AAAwBC,IAAAA,OAAO,EAAE,CAAjC;AAAoCC,IAAAA,UAAU,EAAE;AAAhD,GAAP,CADF,KAEK;AACH,WAAO;AACLD,MAAAA,OAAO,EAAE,IAAI9B,WAAJ,GAAkBwB,YADtB;AAELO,MAAAA,UAAU,EAAEP,YAAY,GAAGxB,WAFtB;AAGL4B,MAAAA,KAAK,EACHJ,YAAY,GAAGxB,WAAf,GACIF,QAAQ,CAAE,SAAQiB,YAAY,GAAG,CAAE,EAA3B,CADZ,GAEIjB,QAAQ,CAAE,SAAQiB,YAAa,EAAvB;AANT,KAAP;AAQD;AACF,CAjBD","sourcesContent":["import { Dispatch } from \"redux\";\nimport axios from \"axios\";\n\n// Actions and types\nimport * as t from \"../types\";\nimport { FarmAction } from \"../actions\";\nimport { BoxStage, Box } from \"../actions/farm\";\n\n// Rootstate\nimport { RootState } from \"../reducers\";\n\n// Utils\nimport { indexerAPI, waterPeriod } from \"../../utils/global\";\n\nexport const loadBoxes =\n  () =>\n  async (dispatch: Dispatch<FarmAction>, getState: () => RootState): Promise<void> => {\n    const { accountPkh } = getState().wallet;\n\n    try {\n      // Retrieve boxes\n      const _res = await axios.get(`${indexerAPI}/boxes?address=${accountPkh}`);\n      const boxes: Box[] = [];\n      // Iterate and assign stages\n      for (const box of _res.data) {\n        boxes.push({\n          key: box.key,\n          ...findStage(parseInt(box.timesWatered), box.lastWatered),\n        });\n      }\n\n      dispatch({\n        type: t.FarmActionTypes.LOAD_BOXES,\n        payload: boxes,\n      });\n    } catch (err) {\n      console.error(err);\n    }\n  };\n\nconst findStage = (\n  timesWatered: number,\n  lastWatered: string\n): { stage: BoxStage; needsWater: boolean; waterBy: number } => {\n  const notWateredIn = Date.now() - new Date(lastWatered).getTime();\n  if (notWateredIn > 2 * waterPeriod && timesWatered !== 5)\n    return { stage: BoxStage.DEAD, waterBy: 0, needsWater: false };\n  else {\n    return {\n      waterBy: 2 * waterPeriod - notWateredIn,\n      needsWater: notWateredIn > waterPeriod,\n      stage:\n        notWateredIn > waterPeriod\n          ? BoxStage[`STAGE_${timesWatered + 1}` as keyof typeof BoxStage]\n          : BoxStage[`STAGE_${timesWatered}` as keyof typeof BoxStage],\n    };\n  }\n};\n"]},"metadata":{},"sourceType":"module"}